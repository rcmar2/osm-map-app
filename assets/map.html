<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .badge {
      position: absolute; bottom: 6px; left: 8px; padding: 2px 6px; border-radius: 4px;
      background: rgba(0,0,0,0.5); color: #fff; font-size: 11px; z-index: 1000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
  </style>
<style>
  .popup { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  .popup h4 { margin: 0 0 4px; font-size: 14px; }
  .popup .muted { color:#6b7280; font-size:12px; margin-bottom:4px; }
  .popup .op { color:#94a3b8; font-size:12px; margin-bottom:4px; }
  .popup .pow { color:#94a3b8; font-size:12px; margin-bottom:8px; }
  .actions { display:flex; gap:8px; }
  .btn {
    padding:6px 10px; border-radius:8px; font-size:12px; border:1px solid #2563eb;
    background:#1d4ed8; color:#fff;
  }
  .btn:hover { filter:brightness(1.05); }
</style>
 
</head>
<body>
  <div id="map"></div>
  <div class="badge">© OpenStreetMap contributors | © Sygic</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://maps.api.sygic.com/js/leaflet.sygic-1.1.0.js"></script>

  <script>
    let map;
    let stations = [];                 // [{...s, layer: L.Marker}]
    let clusterGroup;                  // L.MarkerClusterGroup
    let plainGroup;                    // L.LayerGroup (non-cluster mode)
    let clusteringOn = true;           // current clustering state
    let lastMinKw = 0;                 // remember last applied filter
    let pendingStationsData = null;    // buffer if stations arrive before init

    function postToRN(type, payload) {
      try {
         window.ReactNativeWebView?.postMessage(JSON.stringify({ type, ...payload }));
       } catch (e) { console.log(e); }
    }

function buildPopupHTML(s) {
  const addr = [s.street || "", s.city || "", s.country || ""].filter(Boolean).join(" ");
  const power = (s.power ?? "?") + " kW";
  const hdv = s.hdv || "-";
  return `
    <div class="popup">
      <h4>${s.name || "Unnamed"}</h4>
      <div class="muted">${addr || "Unknown address"}</div>
      <div class="op">${s.operator || "N/A"}</div>
      <div class="pow">${power} · ${hdv}</div>
      <div class="actions">
        <button class="btn btn-nav" data-id="${s._id || ""}">Navigate to</button>
        <button class="btn btn-fav" data-id="${s._id || ""}">Add to favorites</button>
      </div>
    </div>`;
}


    // --- helper: build a simple SVG pin icon in given color ---
    function makePinIcon(color) {
      const svg =
        `<svg width="24" height="36" viewBox="0 0 24 36" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 0C5.925 0 1 4.925 1 11c0 7.5 8.5 15.5 10.2 17.1a1.2 1.2 0 0 0 1.6 0C14.5 26.5 23 18.5 23 11 23 4.925 18.075 0 12 0z" fill="${color}" stroke="white" stroke-width="1"/>
          <circle cx="12" cy="11" r="4" fill="white" opacity="0.9"/>
        </svg>`;
      const url = 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg);
      return L.icon({
        iconUrl: url,
        iconSize: [24, 36],
        iconAnchor: [12, 36],
        popupAnchor: [0, -28],
      });
    }

    function ensureGroups() {
      if (!clusterGroup) {
        clusterGroup = L.markerClusterGroup({
          disableClusteringAtZoom: 12,
          spiderfyOnMaxZoom: true,
          showCoverageOnHover: false,
        });
      }
      if (!plainGroup) {
        plainGroup = L.layerGroup();
      }
    }

    function initMap(sygicKey) {
      if (map) return; // idempotent
      map = L.map('map');
      L.TileLayer.sygic(sygicKey, { poi: true }).addTo(map);

      // Fit a wide Central Europe view
      const sw = L.latLng(45.0, 5.0);
      const ne = L.latLng(55.5, 20.0);
      map.fitBounds(L.latLngBounds(sw, ne));

      ensureGroups();
      map.addLayer(clusterGroup); // default: clustering enabled

      // if we received stations before init, render them now
      if (pendingStationsData) {
        renderStations(pendingStationsData);
        pendingStationsData = null;
      }
      if (lastMinKw > 0) applyFilter(lastMinKw);
    }

    function clearAllGroups() {
      ensureGroups();
      clusterGroup.clearLayers();
      plainGroup.clearLayers();
    }

    function activeGroup() {
      return clusteringOn ? clusterGroup : plainGroup;
    }

    function addActiveGroupToMap() {
      ensureGroups();
      if (clusteringOn) {
        if (map.hasLayer(plainGroup)) map.removeLayer(plainGroup);
        if (!map.hasLayer(clusterGroup)) map.addLayer(clusterGroup);
      } else {
        if (map.hasLayer(clusterGroup)) map.removeLayer(clusterGroup);
        if (!map.hasLayer(plainGroup)) map.addLayer(plainGroup);
      }
    }

    function renderStations(data) {
      if (!map) { pendingStationsData = data; return; }
      ensureGroups();
      clearAllGroups();

      stations = data.map((s) => {
        const hdv = (s.hdv || "").toUpperCase();
        const heavy = hdv.includes("N2") || hdv.includes("N3");
        const color = heavy ? "#ff7b00" : "#007bff"; // orange vs blue
        const addr = [s.street || "", s.city || "", s.country || ""].filter(Boolean).join(" ");

        // give an internal id to help RN side if needed
        if (s._id == null) s._id = `${s.lat},${s.lon},${s.name || ""}`;

        const marker = L
         .marker([s.lat, s.lon], { icon: makePinIcon(color) })
         .bindPopup(buildPopupHTML(s));

        marker.on("popupopen", (e) => {
           const el = e.popup.getElement();
           if (!el) return;

           // stop map interactions when pressing buttons
           L.DomEvent.disableClickPropagation(el);

           const onNav = () => postToRN("navigateTo", { station: s });

           const onFav = () => {
              postToRN("addFavorite", { station: s });
              map.closePopup(); // ✅ closes the currently open popup
           };

           const navBtn = el.querySelector(".btn-nav");
           const favBtn = el.querySelector(".btn-fav");
           if (navBtn) navBtn.addEventListener("click", onNav);
           if (favBtn) favBtn.addEventListener("click", onFav);

           // cleanup when popup closes
           marker.once("popupclose", () => {
              if (navBtn) navBtn.removeEventListener("click", onNav);
              if (favBtn) favBtn.removeEventListener("click", onFav);
           });
        });

        return { ...s, layer: marker };
      });

      // add respecting current filter + clustering state
      const group = activeGroup();
      stations.forEach((s) => {
        const show = (Number(s.power) || 0) >= (lastMinKw || 0);
        if (show) group.addLayer(s.layer);
      });

      addActiveGroupToMap();
    }

    function applyFilter(minKw) {
      lastMinKw = Number(minKw) || 0;
      ensureGroups();

      const group = activeGroup();
      group.clearLayers();
      stations.forEach((s) => {
        const show = (Number(s.power) || 0) >= lastMinKw;
        if (show) group.addLayer(s.layer);
      });
    }

    function toggleClustering(enabled) {
      enabled = !!enabled;
      if (enabled === clusteringOn) return;

      clusteringOn = enabled;
      addActiveGroupToMap();

      // Re-apply current filter into the (new) active group
      applyFilter(lastMinKw);
    }
  
    function focusStation(lat, lon) {
        if (!map) return;
        map.setView([lat, lon], 15, { animate: true });
        //map.flyTo([lat, lon], 16, { animate: true, duration: 1.2 });
    }

    // Message bridge
    function handleMsg(e) {
      try {
        const msg = JSON.parse(e.data);
        if (msg.type === "init") {
          initMap(msg.sygicKey);
        } else if (msg.type === "setStations") {
          renderStations(msg.data || []);
        } else if (msg.type === "applyFilter") {
          applyFilter(Number(msg.minKw) || 0);
        } else if (msg.type === "toggleClustering") {
          toggleClustering(!!msg.enabled);
        }
        else if (msg.type === "focusStation" && msg.lat && msg.lon) {
          focusStation(msg.lat, msg.lon);
        }
      } catch (err) {
        console.error(err);
      }
    }
    document.addEventListener("message", handleMsg);
    window.addEventListener("message", handleMsg);
  </script>
</body>
</html>
