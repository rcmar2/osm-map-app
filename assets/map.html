<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .badge {
      position: absolute; bottom: 6px; left: 8px; padding: 2px 6px; border-radius: 4px;
      background: rgba(0,0,0,0.5); color: #fff; font-size: 11px; z-index: 1000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="badge">© OpenStreetMap contributors | © Sygic</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://maps.api.sygic.com/js/leaflet.sygic-1.1.0.js"></script>

  <script>
    let map;
    let stations = [];                 // [{...s, layer: L.Marker}]
    let clusterGroup;                  // L.MarkerClusterGroup
    let plainGroup;                    // L.LayerGroup (non-cluster mode)
    let clusteringOn = true;           // current clustering state
    let lastMinKw = 0;                 // remember last applied filter
    let pendingStationsData = null;    // buffer if stations arrive before init

    // --- helper: build a simple SVG pin icon in given color ---
    function makePinIcon(color) {
      const svg =
        `<svg width="24" height="36" viewBox="0 0 24 36" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 0C5.925 0 1 4.925 1 11c0 7.5 8.5 15.5 10.2 17.1a1.2 1.2 0 0 0 1.6 0C14.5 26.5 23 18.5 23 11 23 4.925 18.075 0 12 0z" fill="${color}" stroke="white" stroke-width="1"/>
          <circle cx="12" cy="11" r="4" fill="white" opacity="0.9"/>
        </svg>`;
      const url = 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg);
      return L.icon({
        iconUrl: url,
        iconSize: [24, 36],
        iconAnchor: [12, 36],
        popupAnchor: [0, -28],
      });
    }

    function ensureGroups() {
      if (!clusterGroup) {
        clusterGroup = L.markerClusterGroup({
          disableClusteringAtZoom: 12,
          spiderfyOnMaxZoom: true,
          showCoverageOnHover: false,
        });
      }
      if (!plainGroup) {
        plainGroup = L.layerGroup();
      }
    }

    function initMap(sygicKey) {
      if (map) return; // idempotent
      map = L.map('map');
      L.TileLayer.sygic(sygicKey, { poi: true }).addTo(map);

      // Fit a wide Central Europe view
      const sw = L.latLng(45.0, 5.0);
      const ne = L.latLng(55.5, 20.0);
      map.fitBounds(L.latLngBounds(sw, ne));

      ensureGroups();
      map.addLayer(clusterGroup); // default: clustering enabled

      // if we received stations before init, render them now
      if (pendingStationsData) {
        renderStations(pendingStationsData);
        pendingStationsData = null;
      }
      if (lastMinKw > 0) applyFilter(lastMinKw);
    }

    function clearAllGroups() {
      ensureGroups();
      clusterGroup.clearLayers();
      plainGroup.clearLayers();
    }

    function activeGroup() {
      return clusteringOn ? clusterGroup : plainGroup;
    }

    function addActiveGroupToMap() {
      ensureGroups();
      if (clusteringOn) {
        if (map.hasLayer(plainGroup)) map.removeLayer(plainGroup);
        if (!map.hasLayer(clusterGroup)) map.addLayer(clusterGroup);
      } else {
        if (map.hasLayer(clusterGroup)) map.removeLayer(clusterGroup);
        if (!map.hasLayer(plainGroup)) map.addLayer(plainGroup);
      }
    }

    function renderStations(data) {
      if (!map) { pendingStationsData = data; return; }
      ensureGroups();
      clearAllGroups();

      stations = data.map((s) => {
        const hdv = (s.hdv || "").toUpperCase();
        const heavy = hdv.includes("N2") || hdv.includes("N3");
        const color = heavy ? "#ff7b00" : "#007bff"; // orange vs blue
        const addr = [s.street || "", s.city || "", s.country || ""].filter(Boolean).join(" ");
        const popup =
          `<b>${s.name || "Unnamed"}</b><br/>
           ${addr}<br/>
           Operator: ${s.operator || "N/A"}<br/>
           Power: ${(s.power ?? "?")} kW`;

        const marker = L.marker([s.lat, s.lon], { icon: makePinIcon(color) }).bindPopup(popup);
        return { ...s, layer: marker };
      });

      // add respecting current filter + clustering state
      const group = activeGroup();
      stations.forEach((s) => {
        const show = (Number(s.power) || 0) >= (lastMinKw || 0);
        if (show) group.addLayer(s.layer);
      });

      addActiveGroupToMap();
    }

    function applyFilter(minKw) {
      lastMinKw = Number(minKw) || 0;
      ensureGroups();

      const group = activeGroup();
      group.clearLayers();
      stations.forEach((s) => {
        const show = (Number(s.power) || 0) >= lastMinKw;
        if (show) group.addLayer(s.layer);
      });
    }

    function toggleClustering(enabled) {
      enabled = !!enabled;
      if (enabled === clusteringOn) return;

      clusteringOn = enabled;
      addActiveGroupToMap();

      // Re-apply current filter into the (new) active group
      applyFilter(lastMinKw);
    }

    // Message bridge
    function handleMsg(e) {
      try {
        const msg = JSON.parse(e.data);
        if (msg.type === "init") {
          initMap(msg.sygicKey);
        } else if (msg.type === "setStations") {
          renderStations(msg.data || []);
        } else if (msg.type === "applyFilter") {
          applyFilter(Number(msg.minKw) || 0);
        } else if (msg.type === "toggleClustering") {
          toggleClustering(!!msg.enabled);
        }
      } catch (err) {
        console.error(err);
      }
    }
    document.addEventListener("message", handleMsg);
    window.addEventListener("message", handleMsg);
  </script>
</body>
</html>
